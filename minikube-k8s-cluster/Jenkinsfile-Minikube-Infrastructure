pipeline {
    agent {
        label 'ec2-agent-1'
    }
    
    environment {
        CLUSTER_NAME = "minikube-demo-${BUILD_NUMBER}"
        TERRAFORM_VERSION = '1.12.2'
        DEPLOY_CLUSTER = "${params.DEPLOY_CLUSTER ?: 'false'}"
        DESTROY_CLUSTER = "${params.DESTROY_CLUSTER ?: 'false'}"
        MINIKUBE_VERSION = "${params.MINIKUBE_VERSION ?: 'v1.32.0'}"
        KUBERNETES_VERSION = "${params.KUBERNETES_VERSION ?: 'v1.28.3'}"
        HOME = "/home/ec2-user"
        PATH = "/usr/local/bin:/usr/bin:/bin:$PATH"
    }
    
    parameters {
        booleanParam(
            name: 'DEPLOY_CLUSTER',
            defaultValue: false,
            description: 'ğŸš€ Deploy new Minikube cluster on AWS EC2'
        )
        booleanParam(
            name: 'DESTROY_CLUSTER',
            defaultValue: false,
            description: 'ğŸ”¥ Destroy existing Minikube cluster and infrastructure'
        )
        choice(
            name: 'INSTANCE_TYPE',
            choices: ['t3.medium', 't3.large', 't3.xlarge', 't2.medium', 't2.large', 'm5.large'],
            description: 'EC2 instance type (minimum t3.medium for Minikube)'
        )
        choice(
            name: 'AWS_REGION',
            choices: ['us-west-2', 'us-east-1', 'eu-west-1', 'ap-south-1'],
            description: 'AWS region for deployment'
        )
        string(
            name: 'MINIKUBE_VERSION',
            defaultValue: 'v1.32.0',
            description: 'Minikube version to install'
        )
        string(
            name: 'KUBERNETES_VERSION',
            defaultValue: 'v1.28.3',
            description: 'Kubernetes version for Minikube cluster'
        )
        choice(
            name: 'MINIKUBE_MEMORY',
            choices: ['3900', '4096', '6144', '8192'],
            description: 'Memory allocation for Minikube (MB)'
        )
        choice(
            name: 'MINIKUBE_CPUS',
            choices: ['2', '3', '4'],
            description: 'CPU allocation for Minikube'
        )
        string(
            name: 'CLUSTER_NAME',
            defaultValue: 'minikube-demo',
            description: 'Name for the Minikube cluster'
        )
        booleanParam(
            name: 'ENABLE_DASHBOARD',
            defaultValue: true,
            description: 'Enable Kubernetes Dashboard'
        )
        booleanParam(
            name: 'ENABLE_INGRESS',
            defaultValue: true,
            description: 'Enable Ingress Controller'
        )
        booleanParam(
            name: 'ENABLE_REGISTRY',
            defaultValue: true,
            description: 'Enable Local Registry'
        )
    }
    
    stages {
        stage('ğŸ§¹ Clean Workspace') {
            steps {
                echo 'ğŸ§¹ Cleaning workspace to ensure fresh start...'
                script {
                    // Clean the workspace completely
                    deleteDir()
                    
                    // Verify workspace is clean
                    sh '''
                        echo "ğŸ“ Current workspace: ${WORKSPACE}"
                        echo "ğŸ“Š Workspace contents after cleanup:"
                        ls -la || echo "âœ… Workspace is empty (as expected)"
                        
                        echo "ğŸ§¹ Cleaning any leftover Terraform files from previous runs..."
                        rm -rf /tmp/terraform* || true
                        rm -rf /tmp/.terraform* || true
                        rm -rf ~/.terraform.d/checkpoint_cache || true
                        
                        echo "âœ… Workspace cleanup completed"
                    '''
                }
            }
        }
        
        stage('ğŸ” Agent Info & IAM Verification') {
            steps {
                script {
                    echo "ğŸ–¥ï¸ Agent Information:"
                    echo "==================="
                    sh '''
                        echo "Agent Node: ${NODE_NAME}"
                        echo "Workspace: ${WORKSPACE}"
                        echo "OS Info: $(cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2)"
                        echo "User: $(whoami)"
                        echo "Home: ${HOME}"
                        echo "Working Directory: $(pwd)"
                        echo "Available Space: $(df -h . | tail -1 | awk '{print $4}')"
                        echo ""
                        echo "ğŸ” IAM Role Verification:"
                        echo "========================"
                        
                        if aws sts get-caller-identity; then
                            echo ""
                            echo "âœ… IAM role is properly configured"
                            ROLE_ARN=$(aws sts get-caller-identity --query Arn --output text)
                            echo "Current role: $ROLE_ARN"
                            
                            echo ""
                            echo "ğŸ” Testing AWS permissions..."
                            aws ec2 describe-regions --query 'Regions[0].RegionName' --output text > /dev/null && echo "âœ… EC2 permissions: OK"
                            aws ec2 describe-vpcs --region us-west-2 --query 'Vpcs[0].VpcId' --output text > /dev/null && echo "âœ… VPC permissions: OK"
                        else
                            echo "âŒ IAM role not configured or AWS CLI not working"
                            echo "Please ensure:"
                            echo "1. IAM role is attached to this EC2 instance"
                            echo "2. Role has required permissions (EC2, VPC, IAM)"
                            echo "3. AWS CLI is installed"
                            exit 1
                        fi
                    '''
                }
            }
        }
        
        stage('âœ… Validation') {
            steps {
                script {
                    echo "ğŸ” Validating pipeline parameters..."
                    
                    if (params.DEPLOY_CLUSTER && params.DESTROY_CLUSTER) {
                        error("âŒ Cannot deploy and destroy cluster in the same run. Choose one action.")
                    }
                    
                    if (!params.DEPLOY_CLUSTER && !params.DESTROY_CLUSTER) {
                        error("âŒ No action specified. Please select either DEPLOY_CLUSTER or DESTROY_CLUSTER.")
                    }
                    
                    def validInstances = ['t3.medium', 't3.large', 't3.xlarge', 't2.medium', 't2.large', 'm5.large']
                    if (!validInstances.contains(params.INSTANCE_TYPE)) {
                        error("âŒ Invalid instance type. Minikube requires at least t3.medium.")
                    }
                    
                    env.AWS_REGION = params.AWS_REGION
                    env.CLUSTER_NAME = params.CLUSTER_NAME
                    env.MINIKUBE_VERSION = params.MINIKUBE_VERSION
                    env.KUBERNETES_VERSION = params.KUBERNETES_VERSION
                    
                    echo "âœ… Validation completed"
                    echo "ğŸ“‹ Configuration:"
                    echo "   - Action: ${params.DEPLOY_CLUSTER ? 'DEPLOY' : 'DESTROY'}"
                    echo "   - Cluster Name: ${params.CLUSTER_NAME}"
                    echo "   - Region: ${params.AWS_REGION}"
                    echo "   - Instance Type: ${params.INSTANCE_TYPE}"
                    echo "   - Minikube Version: ${params.MINIKUBE_VERSION}"
                    echo "   - Kubernetes Version: ${params.KUBERNETES_VERSION}"
                }
            }
        }
        
        stage('ğŸ”¥ Checkout') {
            steps {
                echo 'ğŸ”¥ Checking out source code...'
                checkout scm
            }
        }
        
        stage('ğŸ”§ Verify Dependencies') {
            steps {
                echo 'ğŸ”§ Verifying required tools on Amazon Linux agent...'
                sh '''
                    echo "Checking Amazon Linux version and package manager..."
                    
                    if [ -f /etc/os-release ]; then
                        . /etc/os-release
                        echo "OS: $PRETTY_NAME"
                        echo "Version: $VERSION_ID"
                        
                        if [[ "$VERSION_ID" == "2023" ]]; then
                            PACKAGE_MANAGER="dnf"
                            echo "Using DNF package manager for Amazon Linux 2023"
                        else
                            PACKAGE_MANAGER="yum"
                            echo "Using YUM package manager for Amazon Linux 2"
                        fi
                    else
                        PACKAGE_MANAGER="yum"
                        echo "Defaulting to YUM package manager"
                    fi
                    
                    install_tool() {
                        local tool=$1
                        local package=$2
                        
                        if command -v $tool &> /dev/null; then
                            echo "âœ… $tool: Already installed"
                            return 0
                        fi
                        
                        echo "Installing $tool using $PACKAGE_MANAGER..."
                        
                        if [[ "$PACKAGE_MANAGER" == "dnf" ]]; then
                            if sudo dnf install -y --allowerasing $package; then
                                echo "âœ… $tool: Installed with DNF"
                                return 0
                            fi
                        else
                            if sudo yum install -y $package; then
                                echo "âœ… $tool: Installed with YUM"
                                return 0
                            fi
                            
                            echo "Retrying with --allowerasing..."
                            if sudo yum install -y --allowerasing $package; then
                                echo "âœ… $tool: Installed with --allowerasing"
                                return 0
                            fi
                            
                            echo "Retrying with --skip-broken..."
                            if sudo yum install -y --skip-broken $package; then
                                echo "âœ… $tool: Installed with --skip-broken"
                                return 0
                            fi
                        fi
                        
                        echo "âš ï¸ Could not install $tool with package manager"
                        return 1
                    }
                    
                    if [[ "$PACKAGE_MANAGER" == "dnf" ]]; then
                        sudo dnf clean all
                    else
                        sudo yum clean all
                    fi
                    
                    echo "Checking installed tools..."
                    
                    if command -v terraform &> /dev/null; then
                        CURRENT_TF_VERSION=$(terraform version | head -1 | grep -o 'v[0-9]\\+\\.[0-9]\\+\\.[0-9]\\+')
                        echo "âœ… Terraform: $CURRENT_TF_VERSION"
                        if [[ "$CURRENT_TF_VERSION" != "v${TERRAFORM_VERSION}" ]]; then
                            echo "âš ï¸ Different version detected. Installing Terraform ${TERRAFORM_VERSION}..."
                            cd /tmp
                            wget -q https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip
                            unzip -o terraform_${TERRAFORM_VERSION}_linux_amd64.zip
                            sudo mv terraform /usr/local/bin/
                            rm terraform_${TERRAFORM_VERSION}_linux_amd64.zip
                            echo "âœ… Terraform ${TERRAFORM_VERSION} installed"
                        fi
                    else
                        echo "âŒ Terraform not found! Installing..."
                        cd /tmp
                        wget -q https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip
                        unzip -o terraform_${TERRAFORM_VERSION}_linux_amd64.zip
                        sudo mv terraform /usr/local/bin/
                        rm terraform_${TERRAFORM_VERSION}_linux_amd64.zip
                        echo "âœ… Terraform ${TERRAFORM_VERSION} installed"
                    fi
                    
                    if command -v aws &> /dev/null; then
                        echo "âœ… AWS CLI: $(aws --version)"
                    else
                        echo "âŒ AWS CLI not found! Installing..."
                        cd /tmp
                        curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                        unzip -o awscliv2.zip
                        sudo ./aws/install --update
                        rm -rf aws awscliv2.zip
                        echo "âœ… AWS CLI installed"
                    fi
                    
                    if command -v kubectl &> /dev/null; then
                        echo "âœ… kubectl: $(kubectl version --client --short 2>/dev/null || echo 'kubectl installed')"
                    else
                        echo "âŒ kubectl not found! Installing..."
                        cd /tmp
                        curl -LO "https://dl.k8s.io/release/${KUBERNETES_VERSION}/bin/linux/amd64/kubectl"
                        chmod +x kubectl
                        sudo mv kubectl /usr/local/bin/
                        echo "âœ… kubectl installed"
                    fi
                    
                    echo "Checking system tools..."
                    install_tool "jq" "jq"
                    install_tool "unzip" "unzip"
                    install_tool "wget" "wget"
                    install_tool "curl" "curl"
                    
                    if [[ "$PACKAGE_MANAGER" == "dnf" ]]; then
                        install_tool "nc" "nmap-ncat"
                    else
                        install_tool "nc" "nc"
                    fi
                    
                    echo "âœ… Git: $(git --version)"
                    echo "âœ… Curl: $(curl --version | head -1)"
                    
                    if command -v java &> /dev/null; then
                        echo "âœ… Java: $(java -version 2>&1 | head -1)"
                    else
                        echo "â„¹ï¸ Java not found (not required for this pipeline)"
                    fi
                    
                    echo ""
                    echo "ğŸ¯ Dependency verification completed!"
                    echo "Package Manager: $PACKAGE_MANAGER"
                    echo "All required tools are available."
                '''
            }
        }
        
        stage('ğŸ—ƒï¸ Prepare Infrastructure') {
            when {
                anyOf {
                    expression { params.DEPLOY_CLUSTER == true }
                    expression { params.DESTROY_CLUSTER == true }
                }
            }
            steps {
                echo 'ğŸ—ƒï¸ Preparing infrastructure configuration...'
                dir('minikube-k8s-cluster/minikube-terraform') {
                    sh '''
                        echo "ğŸ§¹ Cleaning any existing Terraform state and files..."
                        rm -rf .terraform* || true
                        rm -f terraform.tfstate* || true
                        rm -f *.tfplan || true
                        rm -f *.tfvars || true
                        rm -f terraform-*.txt || true
                        rm -f jenkins-kubeconfig.yaml || true
                        rm -f cluster-*.pem || true
                        rm -f cluster-access-info.txt || true
                        
                        echo "ğŸ—‚ï¸ Setting up S3 backend configuration..."
                        # Create backend configuration file for this specific cluster
                        cat <<EOF > backend-config.hcl
bucket = "minikube-terraform-state-bucket"
key    = "minikube-clusters/${CLUSTER_NAME}/terraform.tfstate"
region = "${AWS_REGION}"
encrypt = true
dynamodb_table = "terraform-state-locks"
EOF
                        
                        echo "ğŸ“„ Backend configuration created:"
                        cat backend-config.hcl
                        
                        echo "ğŸ§¹ Checking for leftover IAM resources..."
                        ROLE_NAME="${CLUSTER_NAME}-ec2-role"
                        PROFILE_NAME="${CLUSTER_NAME}-ec2-profile" 
                        POLICY_NAME="${CLUSTER_NAME}-ec2-policy"
                        
                        # Clean up any leftover IAM resources from failed destroy
                        if aws iam get-role --role-name $ROLE_NAME 2>/dev/null; then
                            echo "âš ï¸ Found leftover IAM role $ROLE_NAME, cleaning up..."
                            
                            # Delete policy first
                            aws iam delete-role-policy --role-name $ROLE_NAME --policy-name $POLICY_NAME 2>/dev/null || echo "Policy already deleted"
                            
                            # Remove role from instance profile
                            aws iam remove-role-from-instance-profile --instance-profile-name $PROFILE_NAME --role-name $ROLE_NAME 2>/dev/null || echo "Role already removed from profile"
                            
                            # Delete instance profile
                            aws iam delete-instance-profile --instance-profile-name $PROFILE_NAME 2>/dev/null || echo "Instance profile already deleted"
                            
                            # Delete role
                            aws iam delete-role --role-name $ROLE_NAME 2>/dev/null || echo "Role already deleted"
                            
                            echo "âœ… IAM cleanup completed"
                        else
                            echo "âœ… No conflicting IAM resources found"
                        fi
                        
                        echo "ğŸ“„ Creating fresh terraform.tfvars..."
                        # Create terraform.tfvars without public_key (auto-generated by Terraform)
                        cat <<EOF > terraform.tfvars
# AWS Configuration
aws_region = "${AWS_REGION}"

# Cluster Configuration
cluster_name = "${CLUSTER_NAME}"
environment = "demo"

# Instance Configuration
instance_type = "${INSTANCE_TYPE}"
root_volume_size = 30
use_elastic_ip = true

# Security Configuration
allowed_cidr_blocks = ["0.0.0.0/0"]

# Minikube Configuration
minikube_version = "${MINIKUBE_VERSION}"
kubernetes_version = "${KUBERNETES_VERSION}"
minikube_driver = "docker"
minikube_memory = "${MINIKUBE_MEMORY}"
minikube_cpus = "${MINIKUBE_CPUS}"

# Additional Features
enable_addons = [
EOF
                        
                        if [ "${ENABLE_DASHBOARD}" = "true" ]; then
                            echo '  "dashboard",' >> terraform.tfvars
                        fi
                        if [ "${ENABLE_INGRESS}" = "true" ]; then
                            echo '  "ingress",' >> terraform.tfvars
                        fi
                        if [ "${ENABLE_REGISTRY}" = "true" ]; then
                            echo '  "registry",' >> terraform.tfvars
                        fi
                        echo '  "metrics-server"' >> terraform.tfvars
                        echo ']' >> terraform.tfvars
                        echo '' >> terraform.tfvars
                        echo 'create_jenkins_config = true' >> terraform.tfvars
                        
                        echo "âœ… Terraform configuration prepared"
                        echo "ğŸ“„ terraform.tfvars content:"
                        cat terraform.tfvars
                        echo ""
                        echo "ğŸ”‘ Note: SSH key pair will be auto-generated by Terraform"
                        echo "ğŸ—‚ï¸ Working directory contents:"
                        ls -la
                    '''
                }
            }
        }
        
        stage('ğŸš€ Deploy Minikube Cluster') {
            when {
                expression { params.DEPLOY_CLUSTER == true }
            }
            steps {
                echo 'ğŸš€ Deploying Minikube cluster using IAM role...'
                dir('minikube-k8s-cluster/minikube-terraform') {
                    sh '''
                        echo "ğŸ“„ Initializing Terraform with S3 backend..."
                        rm -rf .terraform* || true
                        terraform init -backend-config=backend-config.hcl
                        
                        echo "ğŸ“‹ Planning deployment..."
                        terraform plan -out=tfplan
                        
                        echo "ğŸ’¾ Saving plan output for review..."
                        terraform show tfplan > terraform-plan-output.txt
                        
                        echo ""
                        echo "ğŸ“‹ TERRAFORM PLAN SUMMARY:"
                        echo "=========================="
                        terraform show -no-color tfplan | head -50
                        echo ""
                        echo "ğŸ“„ Full plan saved to: terraform-plan-output.txt"
                        echo "â³ Waiting for manual approval to proceed with deployment..."
                    '''
                    
                    script {
                        // Show plan summary in Jenkins
                        def planOutput = readFile('terraform-plan-output.txt')
                        def planSummary = planOutput.split('\n')[0..30].join('\n')
                        
                        echo "ğŸ“‹ Terraform Plan Summary (First 30 lines):"
                        echo planSummary
                        
                        // Manual approval step
                        try {
                            timeout(time: 10, unit: 'MINUTES') {
                                def userInput = input(
                                    id: 'terraform-deploy-approval',
                                    message: 'Review the Terraform plan above and decide:',
                                    parameters: [
                                        choice(
                                            name: 'ACTION',
                                            choices: [
                                                'APPROVE - Deploy the infrastructure',
                                                'REJECT - Cancel the deployment'
                                            ],
                                            description: 'Choose your action after reviewing the Terraform plan'
                                        )
                                    ],
                                    submitterParameter: 'APPROVER'
                                )
                                
                                if (userInput.ACTION.startsWith('APPROVE')) {
                                    echo "âœ… Deployment approved by: ${userInput.APPROVER}"
                                    echo "ğŸš€ Proceeding with Terraform apply..."
                                } else {
                                    error("âŒ Deployment rejected by: ${userInput.APPROVER}")
                                }
                            }
                        } catch (Exception e) {
                            error("âŒ Approval timeout or cancelled. Deployment aborted.")
                        }
                    }
                    
                    sh '''
                        echo "ğŸš€ Applying deployment..."
                        terraform apply -auto-approve tfplan
                        
                        echo "ğŸ’¾ Saving outputs..."
                        terraform output -json > terraform-outputs.json
                        
                        echo "âœ… Infrastructure deployment completed!"
                        echo ""
                        echo "ğŸ“Š Deployment Summary:"
                        echo "===================="
                        echo "Instance ID: $(terraform output -raw instance_id)"
                        echo "Public IP: $(terraform output -raw instance_public_ip)"
                        echo "SSH Command: $(terraform output -raw ssh_command)"
                        echo "Private Key: $(terraform output -raw private_key_path)"
                        echo "Minikube Status: $(terraform output -raw minikube_status_command)"
                    '''
                }
            }
        }
        
        stage('â³ Wait for Cluster Readiness') {
            when {
                expression { params.DEPLOY_CLUSTER == true }
            }
            steps {
                echo 'â³ Waiting for Minikube cluster to be ready...'
                dir('minikube-k8s-cluster/minikube-terraform') {
                    sh '''
                        INSTANCE_IP=$(terraform output -raw instance_public_ip)
                        PRIVATE_KEY_PATH=$(terraform output -raw private_key_path)
                        echo "ğŸ” Checking instance readiness: $INSTANCE_IP"
                        echo "ğŸ”‘ Using private key: $PRIVATE_KEY_PATH"
                        
                        echo "â³ Waiting for SSH connection..."
                        timeout 300 bash -c "until nc -z $INSTANCE_IP 22; do sleep 10; echo 'Still waiting for SSH...'; done"
                        echo "âœ… SSH is available"
                        
                        echo "â³ Waiting for Minikube setup to complete..."
                        timeout 1800 bash -c "
                            while true; do
                                if ssh -i $PRIVATE_KEY_PATH -o StrictHostKeyChecking=no -o ConnectTimeout=10 ubuntu@$INSTANCE_IP 'minikube status' 2>/dev/null | grep -q 'Running'; then
                                    echo 'âœ… Minikube is running'
                                    break
                                fi
                                echo 'Still waiting for Minikube...'
                                sleep 30
                            done
                        "
                        
                        echo "ğŸ” Verifying cluster functionality..."
                        ssh -i $PRIVATE_KEY_PATH -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
                            echo '=== Cluster Status ==='
                            minikube status
                            echo ''
                            echo '=== Nodes ==='
                            kubectl get nodes -o wide
                            echo ''
                            echo '=== System Pods ==='
                            kubectl get pods -n kube-system
                            echo ''
                            echo '=== Enabled Addons ==='
                            minikube addons list | grep enabled
                        "
                        
                        echo "ğŸ‰ Minikube cluster is ready!"
                    '''
                }
            }
        }
        
        stage('ğŸ”§ Configure Jenkins Access') {
            when {
                expression { params.DEPLOY_CLUSTER == true }
            }
            steps {
                echo 'ğŸ”§ Configuring Jenkins access to cluster...'
                dir('minikube-k8s-cluster/minikube-terraform') {
                    sh '''
                        INSTANCE_IP=$(terraform output -raw instance_public_ip)
                        PRIVATE_KEY_PATH=$(terraform output -raw private_key_path)
                        
                        echo "ğŸ“¥ Downloading kubeconfig from instance..."
                        ssh -i $PRIVATE_KEY_PATH -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
                            cat ~/.kube/config
                        " > jenkins-kubeconfig.yaml
                        
                        echo "âœ… Kubeconfig downloaded"
                        echo "ğŸ“Š Kubeconfig size: $(wc -l < jenkins-kubeconfig.yaml) lines"
                        
                        # Copy the generated private key to workspace for convenience
                        cp $PRIVATE_KEY_PATH ./cluster-ssh-key.pem
                        chmod 600 ./cluster-ssh-key.pem
                        
                        cat <<EOF > cluster-access-info.txt
ğŸ‰ Minikube Cluster Access Information
====================================

Cluster Name: ${CLUSTER_NAME}
Public IP: $INSTANCE_IP
SSH Command: ssh -i cluster-ssh-key.pem ubuntu@$INSTANCE_IP

Files in Jenkins Workspace:
- jenkins-kubeconfig.yaml (Kubernetes config)
- cluster-ssh-key.pem (SSH private key)
- cluster-access-info.txt (This file)

Dashboard Command: minikube dashboard --url

To access cluster:
1. Download files from Jenkins workspace
2. SSH to instance: ssh -i cluster-ssh-key.pem ubuntu@$INSTANCE_IP
3. Use kubectl: kubectl --kubeconfig=jenkins-kubeconfig.yaml get nodes

IAM Role Used: $(aws sts get-caller-identity --query Arn --output text)
Setup completed at: $(date)

Access Your Application:
- NodePort URL: http://$INSTANCE_IP:30080
- Dashboard URL: http://$INSTANCE_IP:8080 (after port-forward)

Commands to try:
kubectl --kubeconfig=jenkins-kubeconfig.yaml get nodes
kubectl --kubeconfig=jenkins-kubeconfig.yaml get pods --all-namespaces
EOF
                        
                        echo "ğŸ“„ Cluster access information saved"
                    '''
                }
            }
        }
        
        stage('ğŸ”¥ Cluster Health Check') {
            when {
                expression { params.DEPLOY_CLUSTER == true }
            }
            steps {
                echo 'ğŸ”¥ Performing cluster health check...'
                dir('minikube-k8s-cluster/minikube-terraform') {
                    sh '''
                        INSTANCE_IP=$(terraform output -raw instance_public_ip)
                        PRIVATE_KEY_PATH=$(terraform output -raw private_key_path)
                        
                        ssh -i $PRIVATE_KEY_PATH -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
                            echo 'ğŸ”¥ Comprehensive Cluster Health Check'
                            echo '====================================='
                            echo ''
                            
                            echo 'ğŸ“Š Minikube Status:'
                            minikube status
                            echo ''
                            
                            echo 'ğŸ–¥ï¸ Node Information:'
                            kubectl get nodes -o wide
                            echo ''
                            
                            echo 'ğŸ“¦ System Pods Status:'
                            kubectl get pods -n kube-system
                            echo ''
                            
                            echo 'ğŸ”§ Enabled Addons:'
                            minikube addons list | grep enabled
                            echo ''
                            
                            echo 'ğŸŒ Services:'
                            kubectl get svc --all-namespaces
                            echo ''
                            
                            echo 'ğŸ’¾ Storage Classes:'
                            kubectl get storageclass
                            echo ''
                            
                            echo 'ğŸ”’ RBAC Check:'
                            kubectl get clusterrolebinding jenkins-deployer || echo 'Jenkins RBAC not found'
                            echo ''
                            
                            echo 'ğŸ¯ Test Pod Deployment:'
                            kubectl run test-nginx --image=nginx:latest --port=80 --dry-run=client -o yaml | kubectl apply -f -
                            sleep 5
                            kubectl get pod test-nginx
                            kubectl delete pod test-nginx --force --grace-period=0
                            echo ''
                            
                            echo 'âœ… Health check completed successfully!'
                        "
                    '''
                }
            }
        }
        
        stage('ğŸ”¥ Destroy Cluster') {
            when {
                expression { params.DESTROY_CLUSTER == true }
            }
            steps {
                echo 'ğŸ”¥ Destroying Minikube cluster and infrastructure using IAM role...'
                dir('minikube-k8s-cluster/minikube-terraform') {
                    sh '''
                        echo "ğŸ“„ Initializing Terraform with S3 backend..."
                        rm -rf .terraform* || true
                        terraform init -backend-config=backend-config.hcl
                        
                        echo "ğŸ“‹ Planning destruction..."
                        terraform plan -destroy -out=destroy-plan
                        
                        echo "ğŸ’¾ Saving destroy plan for review..."
                        terraform show destroy-plan > terraform-destroy-plan.txt
                        
                        echo ""
                        echo "ğŸ”¥ TERRAFORM DESTROY PLAN:"
                        echo "========================="
                        terraform show -no-color destroy-plan | head -30
                        echo ""
                        echo "ğŸ“„ Full destroy plan saved to: terraform-destroy-plan.txt"
                        echo "â³ Waiting for manual approval to proceed with destruction..."
                    '''
                    
                    script {
                        // Show destroy plan summary
                        def destroyPlan = readFile('terraform-destroy-plan.txt')
                        def destroySummary = destroyPlan.split('\n')[0..20].join('\n')
                        
                        echo "ğŸ”¥ Terraform Destroy Plan Summary:"
                        echo destroySummary
                        
                        // Manual approval for destruction
                        try {
                            timeout(time: 5, unit: 'MINUTES') {
                                def userInput = input(
                                    id: 'terraform-destroy-approval',
                                    message: 'DANGER: This will destroy all infrastructure! Review the plan above:',
                                    parameters: [
                                        choice(
                                            name: 'ACTION',
                                            choices: [
                                                'APPROVE - Destroy the infrastructure',
                                                'REJECT - Cancel the destruction'
                                            ],
                                            description: 'Choose your action after reviewing the destroy plan'
                                        ),
                                        string(
                                            name: 'CONFIRMATION',
                                            defaultValue: '',
                                            description: 'Type "DESTROY" to confirm you want to destroy all infrastructure'
                                        )
                                    ],
                                    submitterParameter: 'APPROVER'
                                )
                                
                                if (userInput.ACTION.startsWith('APPROVE') && userInput.CONFIRMATION == 'DESTROY') {
                                    echo "âœ… Destruction approved by: ${userInput.APPROVER}"
                                    echo "ğŸ”¥ Proceeding with infrastructure destruction..."
                                } else if (userInput.ACTION.startsWith('APPROVE')) {
                                    error("âŒ Destruction cancelled: Confirmation text 'DESTROY' not provided")
                                } else {
                                    error("âŒ Destruction rejected by: ${userInput.APPROVER}")
                                }
                            }
                        } catch (Exception e) {
                            error("âŒ Destroy approval timeout or cancelled. Destruction aborted.")
                        }
                    }
                    
                    sh '''
                        echo "ğŸ”¥ Destroying infrastructure..."
                        terraform apply -auto-approve destroy-plan
                        
                        echo "ğŸ§¹ Cleaning up all files..."
                        rm -f terraform.tfvars tfplan destroy-plan terraform-outputs.json 
                        rm -f terraform-plan-output.txt terraform-destroy-plan.txt 
                        rm -f jenkins-kubeconfig.yaml cluster-access-info.txt cluster-ssh-key.pem
                        rm -f *.pem *.yaml *.json *.txt *.tfplan
                        rm -rf .terraform* || true
                        rm -f terraform.tfstate* || true
                        
                        echo "ğŸ—‚ï¸ Verifying cleanup..."
                        ls -la || echo "âœ… Directory is clean"
                        
                        echo "âœ… Infrastructure destroyed successfully!"
                        echo "ğŸ’° All AWS resources have been cleaned up"
                    '''
                }
            }
        }
    }
    
    post {
        always {
            echo 'ğŸ§¹ Performing comprehensive workspace cleanup...'
            script {
                try {
                    dir('minikube-k8s-cluster/minikube-terraform') {
                        sh '''
                            echo "ğŸ—‚ï¸ Cleaning Terraform working directory..."
                            rm -rf .terraform* || true
                            rm -f terraform.tfstate* || true
                            rm -f *.tfplan || true
                            rm -f *.tfvars || true
                            rm -f terraform-*.txt || true
                            rm -f jenkins-kubeconfig.yaml || true
                            rm -f cluster-*.pem || true
                            rm -f cluster-access-info.txt || true
                            rm -f *.json || true
                            rm -f temp-* || true
                            
                            echo "ğŸ“Š Directory contents after cleanup:"
                            ls -la || echo "âœ… Directory is clean"
                        '''
                    }
                } catch (Exception e) {
                    echo "âš ï¸ Warning: Could not clean terraform directory: ${e.message}"
                }
                
                sh '''
                    echo "ğŸ§¹ Cleaning global temporary files..."
                    rm -rf /tmp/terraform* || true
                    rm -rf /tmp/.terraform* || true
                    rm -rf /tmp/jenkins-* || true
                    
                    echo "ğŸ—‘ï¸ Cleaning workspace root..."
                    find ${WORKSPACE} -name "*.tfstate*" -delete || true
                    find ${WORKSPACE} -name "*.tfplan" -delete || true
                    find ${WORKSPACE} -name ".terraform*" -type d -exec rm -rf {} + || true
                    
                    echo "âœ… Comprehensive cleanup completed"
                    echo "ğŸ“Š Final workspace size: $(du -sh ${WORKSPACE} 2>/dev/null || echo 'N/A')"
                '''
            }
        }
        
        success {
            script {
                if (params.DEPLOY_CLUSTER) {
                    try {
                        dir('minikube-k8s-cluster/minikube-terraform') {
                            def outputs = readJSON file: 'terraform-outputs.json'
                            echo """
ğŸ‰ Minikube Cluster Deployment Successful!
=========================================

ğŸ“‹ Cluster Information:
â€¢ Cluster Name: ${params.CLUSTER_NAME}
â€¢ Public IP: ${outputs.instance_public_ip.value}
â€¢ Instance Type: ${params.INSTANCE_TYPE}
â€¢ Minikube Version: ${params.MINIKUBE_VERSION}
â€¢ Kubernetes Version: ${params.KUBERNETES_VERSION}

ğŸ”‘ Access Information:
â€¢ SSH: ssh -i cluster-ssh-key.pem ubuntu@${outputs.instance_public_ip.value}
â€¢ Kubeconfig: jenkins-kubeconfig.yaml (in workspace)
â€¢ Private Key: cluster-ssh-key.pem (in workspace)

ğŸ” Security:
â€¢ IAM Role: Used for secure deployment
â€¢ Auto-generated SSH keys
â€¢ No hardcoded credentials
â€¢ Follows AWS security best practices

ğŸ¯ Next Steps:
1. Download jenkins-kubeconfig.yaml and cluster-ssh-key.pem from workspace
2. SSH to instance: ssh -i cluster-ssh-key.pem ubuntu@${outputs.instance_public_ip.value}
3. Run health check: ./cluster-health-check.sh
4. Access dashboard: ./start-dashboard.sh
5. Deploy applications using the kubeconfig

ğŸ’¡ Useful Commands:
â€¢ Check status: kubectl --kubeconfig=jenkins-kubeconfig.yaml get nodes
â€¢ Get pods: kubectl --kubeconfig=jenkins-kubeconfig.yaml get pods --all-namespaces
â€¢ SSH access: ssh -i cluster-ssh-key.pem ubuntu@${outputs.instance_public_ip.value}

ğŸ–¥ï¸ Agent Information:
â€¢ Deployed from: ${env.NODE_NAME}
â€¢ Workspace: ${env.WORKSPACE}
â€¢ IAM Role: Used securely without credentials

ğŸ’° Remember: This cluster costs approximately \$0.04 USD per hour
ğŸ”¥ Use DESTROY_CLUSTER=true when done to avoid charges
"""
                        }
                    } catch (Exception e) {
                        echo "âš ï¸ Could not read terraform outputs, but deployment completed successfully"
                    }
                } else if (params.DESTROY_CLUSTER) {
                    echo """
ğŸ”¥ Minikube Cluster Destruction Completed!
========================================

âœ… All AWS resources have been successfully destroyed
ğŸ’° No further charges will be incurred
ğŸ§¹ Workspace has been cleaned up

ğŸ“Š Summary:
â€¢ Cluster Name: ${params.CLUSTER_NAME}
â€¢ Region: ${params.AWS_REGION}
â€¢ Destruction completed at: ${new Date()}

ğŸ” Security:
â€¢ Used IAM role for secure destruction
â€¢ No credentials exposed
â€¢ Followed AWS security best practices
"""
                }
            }
        }
        
        failure {
            echo """
âŒ Pipeline Failed!
==================

Please check the console output above for specific error details.

Common issues and solutions:
â€¢ IAM permissions: Ensure the EC2 instance has proper IAM role
â€¢ Resource limits: Check AWS service quotas in your region
â€¢ Network connectivity: Verify security groups and VPC settings
â€¢ Terraform state: Check for state file conflicts
â€¢ File conflicts: Workspace has been cleaned for next run

ğŸ§¹ Workspace Status: Cleaned automatically
ğŸ”„ Next Run: Will start with fresh workspace

For support, review the logs and error messages above.
"""
            
            // Additional cleanup on failure
            script {
                try {
                    sh '''
                        echo "ğŸš¨ Performing emergency cleanup after failure..."
                        find ${WORKSPACE} -name "*.tfstate*" -delete || true
                        find ${WORKSPACE} -name "*.tfplan" -delete || true
                        find ${WORKSPACE} -name ".terraform*" -type d -exec rm -rf {} + || true
                        rm -rf /tmp/terraform* || true
                        echo "âœ… Emergency cleanup completed"
                    '''
                } catch (Exception e) {
                    echo "âš ï¸ Could not perform emergency cleanup: ${e.message}"
                }
            }
        }
        
        aborted {
            echo """
â„¹ï¸ Pipeline Aborted!
===================

The pipeline was manually stopped or timed out.

If this was during deployment:
â€¢ Check AWS console for any partially created resources
â€¢ Consider running DESTROY_CLUSTER=true to clean up

If this was during destruction:
â€¢ Manually verify all resources are cleaned up in AWS console
â€¢ Check for any remaining EC2 instances, VPCs, or security groups

ğŸ§¹ Workspace Status: Will be cleaned for next run
ğŸ”„ Next Run: Will start fresh without old files
"""
            
            // Cleanup on abort
            script {
                try {
                    sh '''
                        echo "ğŸ›‘ Performing abort cleanup..."
                        find ${WORKSPACE} -name "*.tfstate*" -delete || true
                        find ${WORKSPACE} -name "*.tfplan" -delete || true
                        rm -rf /tmp/terraform* || true
                        echo "âœ… Abort cleanup completed"
                    '''
                } catch (Exception e) {
                    echo "âš ï¸ Could not perform abort cleanup: ${e.message}"
                }
            }
        }
    }
}